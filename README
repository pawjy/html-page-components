HTML page components
~~~~~~~~~~~~~~~~~~~~

* Files

The |src/page-components.js| file implements elements described in
this document.

The |css/default.css| file describes the default style for these
elements.  Though the file itself is not required to be loaded itself,
some of style rules in the file are effectively required for these
elements rendered as intended.

  <link rel=stylesheet href=css/default.css>
  <script src=src/page-components.js async></script>

* Elements

Following elements and API are available once the script has been
loaded:

** <button is=command-button>

A |button| element whose |is| attribute value is |command-button|
represents a command button.  (Be aware that this implementation does
not support mutation of |is| attribute; it must be set to a value
before the element's insertion into the document.)

The element must has a |data-selector| attribute.  Its value is a
group of selectors that selects an element in the document.

The element must has a |data-command| attribute whose value is the
name of the command.

When the element is clicked, the command specified by the
|data-command| attribute value of the element selected by the
|data-selector| attribute value is invoked.

A command whose name is /name/ for element /element/ can be defined by
setting these two values:

  element.cbCommands[name]   An object.  It can have any property.
  element[name]  A function.  This is the method implementing the command.

** <list-container>

A |list-container| element represents a dynamic list of items.  Its
content model is transparent.

A |list-container| element has a *list*, which is a list of JavaScript
objects.  The list is constructed by the loader whose name is
specified by the |loader| attribute value of the element, defaulted to
|src|.  A *loader* is a definition of type |loader|.

The first |list-main| element descendant of a |list-container| element
is the *list item insertion point* of the |list-container| element.
When the |list-container| element is *rendered*, any child of the list
item insertion point is discarded and the |list-item| elements created
from the items of the list of the element using the selected template
of the |list-container| element are inserted into the list item
insertion point.  The selected template of the |list-container|
element is the first |template| element descendant of the
|list-container| element.

A |list-container| element is rendered when the element is inserted
and has |list-main| element and |template| element descendants, or
when a |list-main| or |template| element or pager button descendant is
inserted.

A *pager button* is a next page button or a previous page button.  A
*next page button* is an |a| or |button| element which has a
|list-next| class.  A *previous page button* is an |a| or |button|
element which has a |list-prev| class.  A page button's |hidden|
attribute is set or removed appropriately, according to whether there
is the next or previous page or not.  When a page button is clicked,
the list is updated to inculude the previous or next page
appropriately and the |list-container| element is rendered.

A |list-container| element has following methods:

  loadNext

    Load and render the next page.  This is equivalent to clicking a
    next page button.

  loadPrev

    Load and render the previous page.  This is equivalent to clicking
    a previous page button.

** <image-editor>

An |image-editor| element represents an editable image.  Its content
can be one or more |image-layer| elements, representing layers in the
image.  The order of child elements (in tree order) is the layers'
compound order, where an earlier element has smaller z-index.

A *layer* can be an image or a placeholder (which is a transparent
image for the purpose of composition).  A layer has *natural width*,
*natural height*, and *scale factor*.  A |canvas| element is inserted
into a |image-layer| element.  A layer's *computed width* and
*computed height* are natural width and natural height multiplied by
scale factor, respectively.  Layeres are rendered within the image
using computed width and computed height.

Initially, a layer is a placeholder.  The |placeholder| class is set
to the element while it is a placeholder.  If a placeholder layer has
a |useplaceholderui| attribute specified, the user can click the
element to open a user interface to set a image (i.e. manually
invoking the |selectImageFromFile| method).  In addition, the user can
drop an image file to the element to set the image.  When the user is
dragging an image file over the element, the |drop-target| class is
set to the element.

When a layer is *set* to an image, its natural width and natural
height are set to the image's width and height, respectively, and its
scale factor is set to 1.

A layer has *left* and *top*, which are offsets from the left and top
edges of the parent |image-editor| element, respectively.  They are
both initially set to zero.  If a |movable| attribute is specified to
an |image-layer| element, the layer is *movable*.  If a layer is
movable, its left and top can be modified by dragging the layer, or
using keyboard arrow keys.

A layer has an *anchor point*.  Initially, the anchor point of a layer
is the top left corner of the layer.  If an |anchorpoint| attribute is
set to |center|, the anchor point of a layer is the center of the
layer both horizontally and vertically.  When a layer is set to an
image, the layer's left and top are modified appropriately such that
the anchor point of the layer in the parent |image-editor| element is
preserved.

An |image-editor| element has *width* and *height*.  An |image-editor|
element can have |width| and |height| content attributes, whose values
must be valid floating-point numbers representing width and height in
pixels, respectively.  If specified, they set width and height of the
element and they are not affected by layers' dimension.  Otherwise,
the width is set to the offset of the rightmost layer's right edge
from the left edge of the element and the height is set to the offset
of the bottommost layer's bottom edge from the top edge of the
element.

An |image-editor| element has these object properties:

  height (read-only)

    The element's height, in pixels.

  width (read-only)

    The element's width, in pixels.

An |image-editor| element has these methods:

  getPNGBlob () : Promise

    Serializes the element as a PNG file.  It returns a promise which
    is fulfilled with a Blob of that file.

  getJPEGBlob () : Promise

    Serializes the element as a JPEG file.  It returns a promise which
    is fulfilled with a Blob of that file.

An |image-layer| element has these object properties:

  left (read-only)

    The layer's left, in pixels.

  top (read-only)

    The layer's top, in pixels.

  height (read-only)

    The layer's computed height, in pixels.

  width (read-only)

    The layer's computed width, in pixels.

An |image-layer| element has these methods:

  selectImageByURL (url : String) : Promise

    Set the layer to an image specified by the URL /url/.  It returns
    a promise which is fulfilled once the image has been loaded.  It
    is rejected if the image cannot be loaded.

  selectImageFromFile () : Promise

    Set the layer to an image for the element by showing a user
    interface to choose a file.  It returns a promise which is
    fulfilled once the image has been loaded.  It is rejected if the
    image cannot be loaded.  This is a |command-button| command.

  startCaptureMode ()

    Starts the element's *camera capture mode*, if not yet and if
    possible.  While the element is in the camera capture mode, a
    |video| element with class |capture| is inserted in the element.
    This is a |command-button| command.

  endCaptureMode ()

    Ends the element's camera capture mode, if the element is in that
    mode.  This is a |command-button| command.

  selectImageFromCaptureModeAndEndCaptureMode () : Promise

    Set the layer to the current snapshot of the camera image.  It
    returns a promise which is fulfilled once the image has been
    loaded.  It is rejected if the image cannot be loaded.  It
    implicitly invokes |endCaptureMode|.  This is a |command-button|
    command.

  rotateClockwise ()

    Set the layer to the result of rotation of the layer π/2 radian
    clockwise.  This is a |command-button| command.

  rotateCounterclockwise ()

    Set the layer to the result of rotation of the layer 3π/2 radian
    clockwise.  This is a |command-button| command.

  setScale (number)

    Set the scale factor of the layer to the argument and set the
    layer to the scaled variant of the layer.

The |resize| event is fired at an |image-editor| or |image-layer|
element when it is initialized and whenever the its width or height
has been changed.

The |change| event is fired at an |image-layer| element when the
element is initialized and whenever the layer is set to a new image or
placeholder.

* Exportable function

By setting the |data-export| attribute of the |script| element loading
the |page-components.js| to a space-separated list of the function
names, the functions can be exported to the global scope.  The
following function is available:

  $fill (root, object)

    Edit any descendant of /root/ with the following conditions:

      An element with |data-field| attribute

        Replace the value of the element by the field value specified
        by the |data-field| attribute.

        For the purpose of this function the *value* of an element
        /element/ is the definition of type |filltype| for /element/'s
        local name:

          |contentattribute|

            The value of /element/ is the |value| content attribute
            value of /element/, if specified, or |null|.

          |idlattribute|

            The value of /element/ is the |value| IDL attribute value
            of /element/.

            |input|, |select|, |textarea|, and |output| elements are
             set to this mode.

          |datetime|

            The value of /element/ is the |datetime| attribute value
            and is set to the result of the |new Date (/field value/ *
            1000).toISOString ()|.  If it throws, the |datetime|
            attribute is removed and the |textContent| is set to the
            exception.

            In other words, the field value is expected to be a Unix
            time number and the |datetime| attribute is set to its
            global date and time string equivalent.

            Note that the |textContent| of /element/ is not updated
            when the |datetime| attribute value is changed.  It should
            be handled by another JavaScript codes, such as time.js
            <https://github.com/wakaba/timejs>.

            |time| element is set to this mode.

          Any other value

            The |textContent| IDL attribute value of /element/.

      An element with data-/*/-field attribute

        ... where /*/ is the *target attribute name* and is one of:
        |href|, |src|, |id|, |title|

        The attribute whose name is the target attribute name is set
        to the field value for the |data-/*/-field| attribute value.
        If the field value is |null| or |undefined|, the attribute
        whose name is the target attribute name is removed instead.

        For example,

          <a data-href-field=link data-field=title></a>

        ... with /object/:

          {
            link: "https://example.com/",
            title: "Example Web Page",
          }

        ... is expanded as:

          <a data-href-field=link data-field=title
              href="https://example.com/">Example Web Page</a>

      An element with data-/*/-template attribute

        ... where /*/ is the *target attribute name* and is one of:
        |href|, |src|, |id|, |title|

        The attribute whose name is the target attribute name is set
        to the result of processing the |data-/*/-template| attribute
        value as a value template.

        For example,

          <a data-href-template=https://example.com/{user_id}/{object_id}>

        ... with /object/:

          {
            user_id: 535555,
            object_id: 72534151,
          }

        ... is expanded as:

          <a data-href-template=https://example.com/{user_id}/{object_id}
              href="https://example.com/535555/72534151">

    The *field value* for /field/ is the /field/ property value of
    /object/.  If /field/ contains a |.| character, the substring
    before the character is the property value and the remaining
    substring is interpreted as the field value recursively applied to
    that property value (If the property value is |null| or
    |undefined|, the result is |null|).  For example, field value for
    |abc.def.xyz| is the value of |object.abc.def.xyz|.

    The result of processing a value template /template/ is a copy of
    /template/ where any substring |{/field-name/}| is replaced by the
    field value for /field-name/.

* Definitions

The *definition* is an integration point with another script libraries
and the application.

A definition is represented by an element whose namespace URL is
<data:,pc>.  The definition's *type* is its local name.  The
definition can be registered by inserting the element into the head
element of the document.  There is no way to remove a definition.

The definition's *name* is its |name| attribute value.  A definition
must have a |name| attribute.  The name must be unique for its type.
Predefined names cannot be used as a name.

There are following definition types:

  filltype (string)

    A map entry for |$fill| handling.

  loader (handler)

    A handler for |list-container| element's loader.  It is expected
    to return an object (or a promise fulfulled with an object) with
    following name/value pairs:

      data

        The list, as a JavaScript array.  This value is required.  If
        there is no object, an empty array should be specified.

      next, prev

        An object on the next or previous "page", with following
        name/value pairs:

          ref

            An opaque string to identify the page.

          has

            Whether there is the page or not.

          append, prepend

            Whether the page should be appended or prepended to the
            current list or not.  At most one of them can be set to
            true.  If none is set to true, the current list is cleared
            and then the new list items are inserted.

If a definition type is /handler/, it must have a handler.  The
*handler* of a definition is the |pcHandler| JavaScript property
value, which must be a JavaScript function.

If a definition type is /string/, it must have a content.  The
*content* of a definition is the |content| content attribute value.

There is a predefined loader: |src|.  It fetches the JSON file whose
URL is the |src| attribute value and returns the value for name
specified by the |key| attribute.  For example,

  <list-container src=data.json key=users>
    <template><p data-field=name></template>
    <list-main></list-main>
  </list-container>

  data.json:
  {
    "users": [
      ["name": "Hanako"}
    ]
  }

... will result in:

  <list-container src=data.json key=users>
    <template><p data-field=name></template>
    <list-main><list-item><p data-field=name>Hanako</p></list-item></list-main>
  </list-container>

* Template processing

When a /name/ element is created from an /object/ using /template/,

  - Its |data-requires| attribute value is interpreted as a
    space-separated list of the definition type-name pair separated by
    |:| required to process the template.

  - Its |class| attribute value is set to the |class| attribute value
    of /template/.

  - Its content is set to a deep clone of the template content of
    /template/.

  - The |$fill| function is invoked with it and /object/.

For example, a template:

  <template data-requires=filltype:unit-number>
    <unit-number type=distance data-field=from-station></unit-number>
  </template>

... will be processed after the |filltype| definition for name
|unit-number| is loaded.

* Author

Wakaba <wakaba@suikawiki.org>.

* License

Copyright 2017 Wakaba <wakaba@suikawiki.org>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Affero General Public License for more details.

You does not have received a copy of the GNU Affero General Public
License along with this program, see <https://www.gnu.org/licenses/>.
